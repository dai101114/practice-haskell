-- 1. リスト内包表記[f x | x <- xs, p x] は、高階関数map とfilter を使ってどう書き直せるでしょうか。
myListComprehension :: (a -> b) -> (a -> Bool) -> [a] -> [b]
myListComprehension f p xs = (map f . filter p) xs

-- 2. プレリュードでの定義を見ないで以下の高階関数を定義してください。
-- a. リストの要素のすべてが述語を満たすか検査する関数
all' :: (a -> Bool) -> [a] -> Bool
all' p xs = length (filter p xs) == length xs
-- b. リストの要素のどれかが述語を満たすか検査する関数
any' :: (a -> Bool) -> [a] -> Bool
any' p xs = length (filter p xs) > 0
-- c. リストの先頭から述語を満たす連続した要素を取り出す関数
takeWhile' :: (a -> Bool) -> [a] -> [a]
takeWhile' _ [] = []
takeWhile' p (x:xs) | p x = x : takeWhile' p xs
                    | otherwise = []
-- d. リストの先頭から述語を満たす連続した要素を取り除く関数
dropWhile' :: (a -> Bool) -> [a] -> [a]
dropWhile' _ [] = []
dropWhile' p (x:xs) | p x = dropWhile' p xs
                    | otherwise = (x:xs)

-- 3. 関数foldr を用いて、関数map f とfilter p を定義してください。
map' :: (a -> b) -> [a] -> [b]
map' f = foldr ((:) . f) []

filter' :: (a -> Bool) -> [a] -> [a]
filter' p = foldr (\x acc -> if p x then x:acc else acc) []
 
-- 4. foldl を用いて、十進表記を整数に変換する関数
-- dec2int :: [Int] -> Int
-- 以下に使用例を示します。
-- > dec2int [2,3,4,5]
-- 2345

-- 5. プレリュードの定義を見ないで以下の二つの高階関数を定義してください。
-- a. 「引数に組を取る関数」を「カリー化された関数」へ変換する関数
-- curry :: ((a, b) -> c) -> a -> b -> c
-- b. 「引数が二つのカリー化された関数」を「引数に組を取る関数」へ変換する関数
-- uncurry :: (a -> b -> c) -> (a, b) -> c

-- 6. unfold は、リストを生成する単純な再帰の様式を閉じ込めた高階関数で、以下のように定義できます。
-- unfold p h t x | p x = []
--                | otherwise = h x : unfold p h t (t x)
-- 関数unfold を用いて関数chop8、map f、iterate f を再定義してください。

-- 7. パリティービットの概念を用いて、文字列の二進数への変換器が単純な通信エラーを検出できるように改良してください。
-- - 符号化で生成された8ビットの二進数に、1の数が奇数なら1、そうでないなら0になるパリティービットを付加します。
-- - 復号の際は9ビットの二進数のパリティービットが正しいかを検査し、正しければパリティービットを捨て、誤りであればエラーを報告します。

-- 8. 通信エラーの生じる通信路を用いて、直前の問題で定義した文字列を通信するプログラムを試してください。
-- - この通信路は最初のビットを落とすものとします（関数tailをビットのリストに適用することで実現できます）。

-- 9. 関数altMap :: (a -> b) -> (a -> b) -> [a] -> [b] を定義してください。
-- - この関数は、引数で指定された二つの関数をリストの要素に交互に適用します。
-- 以下に使用例を示します。
-- > altMap (+10) (+100) [0,1,2,3,4]
-- [10,101,12,103,14]

-- 10. 第4章の練習問題に出てきたLuhnアルゴリズムを実装する関数を、任意の長さのカード番号を取り扱えるように改良してください。
-- - altMapを用いて関数luhn :: [Int] -> Bool を定義してください。
-- - 自分の銀行のカード番号を使ってテストしましょう。
