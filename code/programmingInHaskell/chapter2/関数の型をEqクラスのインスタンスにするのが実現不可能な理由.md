関数の型を Eq クラスのインスタンスにするのが実現不可能な理由

Haskell では、関数を Eq クラスのインスタンスにすることは基本的に不可能です。その理由は、関数の比較（== や /=）には次のような問題があるからです。

1. 関数を完全に比較することは無限の入力空間では不可能

関数の比較とは、「すべての引数に対して、同じ結果を返すかどうか」を判定することを意味します。

例えば、2 つの関数 f と g を比較するとします：

```haskell
f == g
```

これを実現するには、関数 f と g に渡せるすべての可能な引数を調べ、それぞれの結果が一致するかどうかを判定する必要があります。しかし、以下のようなケースではそれが不可能です：
• 引数が無限の値を取る場合（例: 整数型、リスト型など）。
• 関数自体が無限ループや未定義の動作を含む場合。

したがって、関数同士を正確に比較することは計算理論的に不可能です。

2. 関数は Eq の要件を満たせない

Eq クラスには以下のような性質（合同律）が求められます：
• 反射律: x == x は常に True。
• 対称律: x == y ならば y == x。
• 推移律: x == y かつ y == z ならば x == z。

関数同士を比較する際にこれらの性質を保証することは困難です。たとえば、次のような場合が考えられます：
• 同じ結果を返すが、内部の計算過程が異なる関数。
• ある特定の入力で未定義の動作を持つ関数。

これにより、Eq クラスの要件を満たすことができません。

実現可能なのはどういった場合か？

関数型を Eq クラスのインスタンスにできるのは、次の条件が満たされる場合に限られます：

1. 入力空間が有限である場合

すべての入力を列挙して結果を比較できる場合、関数を Eq のインスタンスにすることが可能です。

例:

```haskell
newtype FiniteFunc = FF (Bool -> Bool)

instance Eq FiniteFunc where
    (FF f) == (FF g) = all (\x -> f x == g x) [False, True]
```

ここでは、入力空間が Bool（True と False のみ）という有限のケースなので、すべての入力を列挙して比較が可能です。

2. 関数の定義が有限の比較可能な形の場合

関数があらかじめ固定された具体的な値（例: 数値リストのマッピング）を持つ場合、Eq を適用できます。

例:

```haskell
data FiniteMapping = FM [(Int, Int)]

instance Eq FiniteMapping where
    (FM f) == (FM g) = f == g
```

ここでは、[(Int, Int)] の形式で関数を表現しているため、Eq インスタンスを利用できます。

まとめ

実現不可能な理由
• 無限の入力空間ではすべての引数に対する比較が不可能。
• 関数が未定義の動作や無限ループを含む場合があり得る。
• Eq の性質（反射律、対称律、推移律）を保証できない場合がある。

実現可能な場合
• 入力空間が有限である場合。
• 関数を有限の具体的なデータ構造で表現できる場合。

このような状況を理解して、条件付きで関数型の比較を設計する必要があります！
